{% extends "base.html" %}

{% block title %}Monitor - Antigravity Manager{% endblock %}

{% block extra_css %}
<style>
    html,
    body {
        overflow: hidden;
    }

    /* Override base.html main padding for monitor page */
    main {
        padding: 0 !important;
    }

    .monitor-page-container {
        height: calc(100vh - 60px);
        padding: 1rem;
        overflow: hidden;
    }

    .monitor-layout {
        display: grid;
        grid-template-columns: 280px 1fr 380px;
        gap: 1rem;
        height: 100%;
    }

    .container-list-panel {
        background-color: #16213e;
        border-radius: 10px;
        padding: 1rem;
        overflow-y: auto;
    }

    .container-list-panel h2 {
        margin-bottom: 1rem;
        color: #e94560;
        font-size: 1.2rem;
    }

    .container-item {
        padding: 0.75rem;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-bottom: 0.5rem;
        border: 1px solid transparent;
    }

    .container-item:hover {
        background-color: rgba(233, 69, 96, 0.1);
    }

    .container-item.selected {
        background-color: rgba(233, 69, 96, 0.2);
        border-color: #e94560;
    }

    .container-item .name {
        font-weight: bold;
        margin-bottom: 0.25rem;
    }

    .container-item .status {
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: inline-block;
    }

    .status-dot.running {
        background-color: #28a745;
    }

    .status-dot.stopped {
        background-color: #dc3545;
    }

    .status-dot.created {
        background-color: #ffc107;
    }

    .container-item .details {
        font-size: 0.8rem;
        color: #888;
        margin-top: 0.25rem;
    }

    .container-actions {
        margin-top: 0.5rem;
        display: flex;
        gap: 0.5rem;
    }

    .container-actions .btn {
        padding: 0.25rem 0.5rem;
        font-size: 0.8rem;
    }

    .vnc-panel {
        background-color: #16213e;
        border-radius: 10px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }

    .vnc-header {
        padding: 0.75rem 1rem;
        border-bottom: 1px solid #333;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .vnc-header h3 {
        color: #e94560;
        font-size: 1rem;
    }

    .vnc-container {
        flex: 1;
        position: relative;
        background-color: #000;
    }

    .vnc-container iframe {
        width: 100%;
        height: 100%;
        border: none;
    }

    .panel-placeholder {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: #666;
    }

    .panel-placeholder.vnc {
        font-size: 1.2rem;
    }

    .conversation-panel {
        background-color: #16213e;
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        overflow: hidden;
    }

    .conversation-tabs {
        display: flex;
        overflow-x: auto;
        border-bottom: 1px solid #333;
        padding: 0.5rem;
        gap: 0.5rem;
        flex-shrink: 0;
    }

    .conversation-tab {
        padding: 0.5rem 1rem;
        background-color: #0f3460;
        border: none;
        border-radius: 5px;
        color: #eee;
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.2s ease;
        font-size: 0.85rem;
    }

    .conversation-tab:hover {
        background-color: rgba(233, 69, 96, 0.3);
    }

    .conversation-tab.active {
        background-color: #e94560;
    }

    .conversation-content {
        flex: 1;
        overflow-y: auto;
        padding: 1rem;
    }

    /* .conversation-placeholder now uses .panel-placeholder */

    .message {
        margin-bottom: 1rem;
        padding: 0.75rem;
        border-radius: 8px;
    }

    .message.user {
        background-color: #0f3460;
        margin-left: 1rem;
    }

    .message.assistant {
        background-color: #1a1a2e;
        border: 1px solid #333;
        margin-right: 1rem;
    }

    .message .role {
        font-weight: bold;
        font-size: 0.85rem;
        margin-bottom: 0.5rem;
    }

    .message.user .role {
        color: #e94560;
    }

    .message.assistant .role {
        color: #28a745;
    }

    .message.error {
        background-color: rgba(220, 53, 69, 0.2);
        border: 1px solid #dc3545;
    }

    .message.error .role {
        color: #dc3545;
    }

    .message .content {
        white-space: pre-wrap;
        word-break: break-word;
        font-size: 0.9rem;
        line-height: 1.5;
    }

    .message.tool {
        background-color: #1a2a1a;
        border: 1px solid #2d5a2d;
        margin: 0.5rem 0;
    }

    .message.tool .role {
        color: #6bcf6b;
    }

    .message.notification {
        background-color: #2a2a1a;
        border: 1px solid #5a5a2d;
    }

    .message.notification .role {
        color: #cfcf6b;
    }

    .message.task {
        background-color: #1a1a2e;
        border: 1px solid #4a4a8a;
        border-left: 3px solid #6b6bcf;
        margin: 0.75rem 0;
    }

    .message.task .role {
        color: #8b8bef;
        font-size: 0.85rem;
    }

    .task-name {
        color: #eee;
        font-weight: bold;
        font-size: 0.95rem;
        margin-bottom: 0.25rem;
    }

    .task-info {
        font-size: 0.8rem;
        color: #888;
    }

    .task-mode {
        display: inline-block;
        padding: 0.15rem 0.4rem;
        border-radius: 3px;
        font-size: 0.7rem;
        font-weight: bold;
        text-transform: uppercase;
    }

    .task-mode.planning {
        background-color: rgba(107, 203, 107, 0.2);
        color: #6bcb6b;
    }

    .task-mode.execution {
        background-color: rgba(107, 163, 203, 0.2);
        color: #6ba3cb;
    }

    .task-mode.verification {
        background-color: rgba(203, 163, 107, 0.2);
        color: #cba36b;
    }

    .collapsible-header {
        display: flex;
        align-items: center;
        cursor: pointer;
        user-select: none;
        gap: 0.5rem;
    }

    .collapsible-header:hover {
        opacity: 0.8;
    }

    .collapse-icon {
        transition: transform 0.2s ease;
        font-size: 0.7rem;
    }

    .collapse-icon.collapsed {
        transform: rotate(-90deg);
    }

    .collapsible-content {
        margin-top: 0.5rem;
        padding-top: 0.5rem;
        border-top: 1px solid #333;
    }

    .collapsible-content.collapsed {
        display: none;
    }

    .tool-command,
    .tool-output {
        font-family: monospace;
        background-color: #0a0a0a;
        padding: 0.5rem;
        border-radius: 4px;
        margin-top: 0.5rem;
        overflow-x: auto;
    }

    .tool-output {
        max-height: 300px;
        overflow: auto;
        font-size: 0.8rem;
    }

    .tool-label {
        font-size: 0.75rem;
        color: #888;
        margin-top: 0.5rem;
        margin-bottom: 0.25rem;
    }

    .no-containers {
        text-align: center;
        color: #666;
        padding: 2rem;
    }

    .refresh-btn {
        background: none;
        border: 1px solid #e94560;
        color: #e94560;
        padding: 0.25rem 0.5rem;
        border-radius: 3px;
        cursor: pointer;
        font-size: 0.8rem;
    }

    .refresh-btn:hover {
        background-color: rgba(233, 69, 96, 0.2);
    }
</style>
{% endblock %}

{% block main_content %}
<div class="monitor-page-container">
    <div class="monitor-layout">
        <!-- Container List Panel -->
        <div class="container-list-panel">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                <h2>Containers</h2>
                <button class="refresh-btn" onclick="refreshContainers()">Refresh</button>
            </div>
            <div id="containerList">
                {% if containers %}
                {% for container in containers %}
                <div class="container-item" data-name="{{ container.name }}"
                    data-novnc-port="{{ container.novnc_port }}" data-api-port="{{ container.api_port }}"
                    data-status="{{ container.status }}" data-display-name="{{ container.display_name }}"
                    onclick="selectContainer(this)">
                    <div class="name">{{ container.display_name }}</div>
                    <div class="status">
                        <span class="status-dot {{ container.status }}"></span>
                        {{ container.status }}
                    </div>
                    <div class="details">
                        {{ container.name }} | IP: {{ container.ip_address or 'N/A' }}<br>
                        noVNC: {{ container.novnc_port or 'N/A' }} | API: {{ container.api_port or 'N/A' }}
                    </div>
                    <div class="container-actions">
                        <button class="btn btn-danger"
                            onclick="event.stopPropagation(); deleteContainer('{{ container.name }}')">Delete</button>
                    </div>
                </div>
                {% endfor %}
                {% else %}
                <div class="no-containers">No containers deployed yet</div>
                {% endif %}
            </div>
        </div>

        <!-- VNC Panel -->
        <div class="vnc-panel">
            <div class="vnc-header">
                <h3>noVNC Viewer</h3>
                <span id="vncContainerName">-</span>
            </div>
            <div class="vnc-container" id="vncContainer">
                <div class="panel-placeholder vnc">Select a container to view</div>
            </div>
        </div>

        <!-- Conversation Panel -->
        <div class="conversation-panel">
            <div class="conversation-tabs" id="conversationTabs">
                <span style="padding: 0.5rem; color: #666;">Select a container</span>
            </div>
            <div class="conversation-content" id="conversationContent">
                <div class="panel-placeholder">Select a container and conversation to view history</div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    let selectedContainer = null;
    let conversations = [];
    let selectedConversationId = null;
    let expandedIds = new Set();

    function selectContainer(element) {
        // Update UI selection
        document.querySelectorAll('.container-item').forEach(item => {
            item.classList.remove('selected');
        });
        element.classList.add('selected');

        const containerName = element.dataset.name;
        const novncPort = element.dataset.novncPort;
        const apiPort = element.dataset.apiPort;
        const status = element.dataset.status;

        selectedContainer = {
            name: containerName,
            novncPort: novncPort,
            apiPort: apiPort,
            status: status
        };

        document.getElementById('vncContainerName').textContent = element.dataset.displayName || containerName;

        // Load VNC
        const vncContainer = document.getElementById('vncContainer');
        if (status === 'running' && novncPort) {
            // Using view_only=true for view-only mode
            vncContainer.innerHTML = `<iframe src="http://${window.location.hostname}:${novncPort}/vnc.html?autoconnect=true&view_only=true&resize=scale"></iframe>`;
        } else {
            vncContainer.innerHTML = `<div class="panel-placeholder vnc">Container is not running</div>`;
        }

        // Load conversations
        loadConversations(containerName);
    }

    async function loadConversations(containerName) {
        const tabsContainer = document.getElementById('conversationTabs');
        const contentContainer = document.getElementById('conversationContent');

        tabsContainer.innerHTML = '<span style="padding: 0.5rem; color: #666;">Loading...</span>';
        contentContainer.innerHTML = '<div class="panel-placeholder">Loading conversations...</div>';

        try {
            const response = await fetch(`/api/container/${containerName}/conversations`);
            const data = await response.json();

            if (response.ok) {
                conversations = data;

                if (conversations.length === 0) {
                    tabsContainer.innerHTML = '<span style="padding: 0.5rem; color: #666;">No conversations</span>';
                    contentContainer.innerHTML = '<div class="panel-placeholder">No conversations found</div>';
                    return;
                }

                // Render tabs (numbered)
                tabsContainer.innerHTML = conversations.map((conv, index) => `
                    <button class="conversation-tab ${index === 0 ? 'active' : ''}"
                            data-id="${conv.id}"
                            onclick="selectConversation('${conv.id}', this)">
                        ${index + 1}
                    </button>
                `).join('');

                // Load first conversation
                if (conversations.length > 0) {
                    selectConversation(conversations[0].id, tabsContainer.querySelector('.conversation-tab'));
                }
            } else {
                tabsContainer.innerHTML = '<span style="padding: 0.5rem; color: #e94560;">Error loading</span>';
                contentContainer.innerHTML = `<div class="panel-placeholder">Error: ${data.error}</div>`;
            }
        } catch (error) {
            tabsContainer.innerHTML = '<span style="padding: 0.5rem; color: #e94560;">Error</span>';
            contentContainer.innerHTML = `<div class="panel-placeholder">Error: ${error.message}</div>`;
        }
    }

    async function selectConversation(conversationId, tabElement) {
        // Update tab selection
        document.querySelectorAll('.conversation-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        if (tabElement) {
            tabElement.classList.add('active');
        }

        selectedConversationId = conversationId;
        const contentContainer = document.getElementById('conversationContent');
        contentContainer.innerHTML = '<div class="panel-placeholder">Loading conversation...</div>';

        if (!selectedContainer) return;

        try {
            const response = await fetch(`/api/container/${selectedContainer.name}/conversation/${conversationId}`);
            const data = await response.json();

            if (response.ok) {
                renderConversation(data);
            } else {
                contentContainer.innerHTML = `<div class="panel-placeholder">Error: ${data.error}</div>`;
            }
        } catch (error) {
            contentContainer.innerHTML = `<div class="panel-placeholder">Error: ${error.message}</div>`;
        }
    }

    function renderConversation(data) {
        const contentContainer = document.getElementById('conversationContent');
        const messages = [];

        // The data structure can vary - try multiple paths
        let steps = [];

        if (data.state && data.state.trajectory && data.state.trajectory.steps) {
            steps = data.state.trajectory.steps;
        } else if (data.trajectory && data.trajectory.steps) {
            steps = data.trajectory.steps;
        } else if (data.steps) {
            steps = data.steps;
        }

        let idCounter = 0;

        for (const step of steps) {
            const stepType = step.type || '';

            // User input
            if (stepType === 'CORTEX_STEP_TYPE_USER_INPUT' && step.userInput) {
                const items = step.userInput.items || [];
                const text = items.map(item => item.text || '').filter(t => t).join('\n');
                if (text) {
                    messages.push({ role: 'user', content: text, id: idCounter++ });
                }
            }

            // Assistant response
            if (stepType === 'CORTEX_STEP_TYPE_PLANNER_RESPONSE' && step.plannerResponse) {
                const response = step.plannerResponse.response || '';
                const thinking = step.plannerResponse.thinking || '';

                if (response || thinking) {
                    messages.push({
                        role: 'assistant',
                        content: response,
                        thinking: thinking,
                        id: idCounter++
                    });
                }
            }

            // Run command (tool call)
            if (stepType === 'CORTEX_STEP_TYPE_RUN_COMMAND' && step.runCommand) {
                const rc = step.runCommand;
                const command = rc.commandLine || rc.command || '';
                const output = rc.combinedOutput?.full || rc.combinedOutput?.truncated || '';
                if (command) {
                    messages.push({
                        role: 'tool',
                        toolType: 'command',
                        toolName: 'Run Command',
                        command: command,
                        output: output,
                        id: idCounter++
                    });
                }
            }

            // Command status (tool output)
            if (stepType === 'CORTEX_STEP_TYPE_COMMAND_STATUS' && step.commandStatus) {
                const cs = step.commandStatus;
                const output = cs.combined || cs.stdout || cs.stderr || '';
                if (output && messages.length > 0) {
                    // Try to attach to previous command
                    const lastMsg = messages[messages.length - 1];
                    if (lastMsg.role === 'tool' && lastMsg.toolType === 'command' && !lastMsg.output) {
                        lastMsg.output = output;
                    }
                }
            }

            // Code action (file edit)
            if (stepType === 'CORTEX_STEP_TYPE_CODE_ACTION' && step.codeAction) {
                const ca = step.codeAction;
                const spec = ca.actionSpec || {};
                // Try multiple paths to find the file path
                let filePath = spec.filePath
                    || spec.createFile?.path?.absoluteUri
                    || spec.createFile?.filePath
                    || spec.editFile?.path?.absoluteUri
                    || spec.editFile?.filePath
                    || ca.actionResult?.edit?.absoluteUri
                    || '';
                // Clean up file:// prefix
                if (filePath.startsWith('file://')) {
                    filePath = filePath.replace('file://', '');
                }
                const instruction = ca.codeInstruction || spec.createFile?.instruction || '';
                messages.push({
                    role: 'tool',
                    toolType: 'code',
                    toolName: 'Code Edit',
                    filePath: filePath || 'Unknown file',
                    instruction: instruction,
                    id: idCounter++
                });
            }

            // View file
            if (stepType === 'CORTEX_STEP_TYPE_VIEW_FILE' && step.viewFile) {
                const vf = step.viewFile;
                const filePath = vf.absolutePathUri || 'Unknown file';
                const content = vf.content || vf.rawContent || '';
                messages.push({
                    role: 'tool',
                    toolType: 'view',
                    toolName: 'View File',
                    filePath: filePath,
                    output: content,
                    id: idCounter++
                });
            }

            // List directory
            if (stepType === 'CORTEX_STEP_TYPE_LIST_DIRECTORY' && step.listDirectory) {
                const ld = step.listDirectory;
                let path = ld.directoryPathUri || ld.absolutePathUri || ld.path || '';
                // Clean up file:// prefix
                if (path.startsWith('file://')) {
                    path = path.replace('file://', '');
                }
                const entries = ld.results || ld.entries || [];
                messages.push({
                    role: 'tool',
                    toolType: 'list',
                    toolName: 'List Directory',
                    filePath: path,
                    output: entries.map(e => `${e.isDir ? '[DIR] ' : ''}${e.name || e}`).join('\n'),
                    id: idCounter++
                });
            }

            // Notify user
            if (stepType === 'CORTEX_STEP_TYPE_NOTIFY_USER' && step.notifyUser) {
                const nu = step.notifyUser;
                const content = nu.notificationContent || nu.message || '';
                if (content) {
                    messages.push({ role: 'notification', content: content });
                }
            }

            // Error messages
            if (stepType === 'CORTEX_STEP_TYPE_ERROR_MESSAGE' && step.errorMessage) {
                const error = step.errorMessage.error || {};
                const errorMsg = error.userErrorMessage || error.shortError || '';
                if (errorMsg) {
                    messages.push({ role: 'error', content: errorMsg });
                }
            }

            // Task boundary
            if (stepType === 'CORTEX_STEP_TYPE_TASK_BOUNDARY') {
                const metadata = step.metadata || {};
                const toolCall = metadata.toolCall || {};
                let taskInfo = {};
                try {
                    taskInfo = JSON.parse(toolCall.argumentsJson || '{}');
                } catch (e) {
                    taskInfo = {};
                }
                // Handle %SAME% placeholders by tracking last values
                if (!window._lastTaskValues) {
                    window._lastTaskValues = { taskName: '', taskStatus: '', taskSummary: '', mode: '' };
                }
                const taskName = (taskInfo.TaskName && taskInfo.TaskName !== '%SAME%') ? taskInfo.TaskName : window._lastTaskValues.taskName;
                const taskStatus = (taskInfo.TaskStatus && taskInfo.TaskStatus !== '%SAME%') ? taskInfo.TaskStatus : window._lastTaskValues.taskStatus;
                const taskSummary = (taskInfo.TaskSummary && taskInfo.TaskSummary !== '%SAME%') ? taskInfo.TaskSummary : window._lastTaskValues.taskSummary;
                const mode = (taskInfo.Mode && taskInfo.Mode !== '%SAME%') ? taskInfo.Mode : window._lastTaskValues.mode;
                // Update last values
                window._lastTaskValues = { taskName, taskStatus, taskSummary, mode };
                if (taskName) {
                    messages.push({
                        role: 'task',
                        taskName: taskName,
                        taskStatus: taskStatus,
                        taskSummary: taskSummary,
                        mode: mode,
                        id: idCounter++
                    });
                }
            }

            // Skip ephemeral messages and conversation history (system-only)
        }

        // If no messages extracted, show raw data
        if (messages.length === 0) {
            contentContainer.innerHTML = `
                <div class="message assistant">
                    <div class="role">Raw Data</div>
                    <div class="content">${JSON.stringify(data, null, 2).substring(0, 5000)}</div>
                </div>
            `;
            return;
        }

        contentContainer.innerHTML = messages.map(msg => {
            if (msg.role === 'user') {
                return `
                    <div class="message user">
                        <div class="role">User</div>
                        <div class="content">${escapeHtml(msg.content)}</div>
                    </div>
                `;
            } else if (msg.role === 'assistant') {
                let thinkingHtml = '';
                if (msg.thinking) {
                    const isExpanded = expandedIds.has('thinking-' + msg.id);
                    const collapsedClass = isExpanded ? '' : 'collapsed';
                    thinkingHtml = `
                        <div class="collapsible-header" onclick="toggleCollapse('thinking-${msg.id}')">
                            <span class="collapse-icon ${collapsedClass}" id="icon-thinking-${msg.id}">▼</span>
                            <span style="color: #888; font-size: 0.8rem;">Thinking...</span>
                        </div>
                        <div id="thinking-${msg.id}" class="collapsible-content ${collapsedClass}">
                            <div class="content" style="color: #888; font-style: italic;">${escapeHtml(msg.thinking)}</div>
                        </div>
                    `;
                }
                return `
                    <div class="message assistant">
                        <div class="role">Assistant</div>
                        ${thinkingHtml}
                        ${msg.content ? `<div class="content">${escapeHtml(msg.content)}</div>` : ''}
                    </div>
                `;
            } else if (msg.role === 'tool') {
                let detailsHtml = '';
                let summaryText = '';
                if (msg.toolType === 'command') {
                    summaryText = msg.command ? escapeHtml(msg.command.substring(0, 60)) + (msg.command.length > 60 ? '...' : '') : '';
                    detailsHtml = `
                        <div class="tool-label">Command:</div>
                        <div class="tool-command">${escapeHtml(msg.command)}</div>
                        ${msg.output ? `<div class="tool-label">Output:</div><div class="tool-output">${escapeHtml(msg.output)}</div>` : ''}
                    `;
                } else if (msg.toolType === 'code') {
                    summaryText = escapeHtml(msg.filePath);
                    detailsHtml = `
                        <div class="tool-label">File: ${escapeHtml(msg.filePath)}</div>
                        ${msg.instruction ? `<div class="tool-output">${escapeHtml(msg.instruction)}</div>` : ''}
                    `;
                } else if (msg.toolType === 'view' || msg.toolType === 'list') {
                    summaryText = escapeHtml(msg.filePath);
                    detailsHtml = `
                        <div class="tool-label">Path: ${escapeHtml(msg.filePath)}</div>
                        ${msg.output ? `<div class="tool-output">${escapeHtml(msg.output.substring(0, 2000))}${msg.output.length > 2000 ? '\n... (truncated)' : ''}</div>` : ''}
                    `;
                }
                const isExpanded = expandedIds.has('tool-' + msg.id);
                const collapsedClass = isExpanded ? '' : 'collapsed';
                return `
                    <div class="message tool">
                        <div class="collapsible-header" onclick="toggleCollapse('tool-${msg.id}')">
                            <span class="collapse-icon ${collapsedClass}" id="icon-tool-${msg.id}">▼</span>
                            <span class="role">${msg.toolName}</span>
                            <span style="color: #888; font-size: 0.8rem; margin-left: 0.5rem;">${summaryText}</span>
                        </div>
                        <div id="tool-${msg.id}" class="collapsible-content ${collapsedClass}">
                            ${detailsHtml}
                        </div>
                    </div>
                `;
            } else if (msg.role === 'notification') {
                return `
                    <div class="message notification">
                        <div class="role">Notification</div>
                        <div class="content">${escapeHtml(msg.content)}</div>
                    </div>
                `;
            } else if (msg.role === 'error') {
                return `
                    <div class="message error">
                        <div class="role">Error</div>
                        <div class="content">${escapeHtml(msg.content)}</div>
                    </div>
                `;
            } else if (msg.role === 'task') {
                const modeClass = msg.mode ? msg.mode.toLowerCase() : '';
                const isExpanded = expandedIds.has('task-' + msg.id);
                const collapsedClass = isExpanded ? '' : 'collapsed';
                return `
                    <div class="message task">
                        <div class="collapsible-header" onclick="toggleCollapse('task-${msg.id}')">
                            <span class="collapse-icon ${collapsedClass}" id="icon-task-${msg.id}">▼</span>
                            <span class="role">Task</span>
                            ${msg.mode ? `<span class="task-mode ${modeClass}">${escapeHtml(msg.mode)}</span>` : ''}
                            <span class="task-name">${escapeHtml(msg.taskName)}</span>
                        </div>
                        <div id="task-${msg.id}" class="collapsible-content ${collapsedClass}">
                            ${msg.taskStatus ? `<div class="task-info"><strong>Status:</strong> ${escapeHtml(msg.taskStatus)}</div>` : ''}
                            ${msg.taskSummary ? `<div class="task-info"><strong>Summary:</strong> ${escapeHtml(msg.taskSummary)}</div>` : ''}
                        </div>
                    </div>
                `;
            }
            return '';
        }).join('');
    }

    function toggleCollapse(id) {
        const content = document.getElementById(id);
        const icon = document.getElementById('icon-' + id);
        if (content) {
            content.classList.toggle('collapsed');
            if (content.classList.contains('collapsed')) {
                expandedIds.delete(id);
            } else {
                expandedIds.add(id);
            }
        }
        if (icon) {
            icon.classList.toggle('collapsed');
        }
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    async function deleteContainer(containerName) {
        if (!confirm(`Are you sure you want to delete ${containerName}?`)) {
            return;
        }

        try {
            const response = await fetch(`/api/container/${containerName}/delete`, {
                method: 'POST'
            });

            if (response.ok) {
                refreshContainers();
            } else {
                const data = await response.json();
                alert(`Failed to delete container: ${data.error}`);
            }
        } catch (error) {
            alert(`Failed to delete container: ${error.message}`);
        }
    }

    async function refreshContainers() {
        try {
            const response = await fetch('/api/containers');
            const containers = await response.json();

            const containerList = document.getElementById('containerList');

            if (containers.length === 0) {
                containerList.innerHTML = '<div class="no-containers">No containers deployed yet</div>';
                return;
            }

            containerList.innerHTML = containers.map(container => `
                <div class="container-item ${selectedContainer && selectedContainer.name === container.name ? 'selected' : ''}"
                     data-name="${container.name}"
                     data-display-name="${container.display_name || container.name}"
                     data-novnc-port="${container.novnc_port || ''}"
                     data-api-port="${container.api_port || ''}"
                     data-status="${container.status}"
                     onclick="selectContainer(this)">
                    <div class="name">${container.display_name || container.name}</div>
                    <div class="status">
                        <span class="status-dot ${container.status}"></span>
                        ${container.status}
                    </div>
                    <div class="details">
                        ${container.name} | IP: ${container.ip_address || 'N/A'}<br>
                        noVNC: ${container.novnc_port || 'N/A'} | API: ${container.api_port || 'N/A'}
                    </div>
                    <div class="container-actions">
                        <button class="btn btn-danger" onclick="event.stopPropagation(); deleteContainer('${container.name}')">Delete</button>
                    </div>
                </div>
            `).join('');
        } catch (error) {
            console.error('Failed to refresh containers:', error);
        }
    }

    // Auto-refresh every 30 seconds
    setInterval(refreshContainers, 30000);

    // Auto-refresh conversation content every 3 seconds
    let conversationRefreshInterval = null;

    async function refreshConversation() {
        if (!selectedContainer || !selectedConversationId) return;

        try {
            const response = await fetch(`/api/container/${selectedContainer.name}/conversation/${selectedConversationId}`);
            const data = await response.json();

            if (response.ok) {
                renderConversation(data);
            }
        } catch (error) {
            console.error('Failed to refresh conversation:', error);
        }
    }

    function startConversationPolling() {
        stopConversationPolling();
        conversationRefreshInterval = setInterval(refreshConversation, 3000);
    }

    function stopConversationPolling() {
        if (conversationRefreshInterval) {
            clearInterval(conversationRefreshInterval);
            conversationRefreshInterval = null;
        }
    }

    // Override selectConversation to start polling
    const originalSelectConversation = selectConversation;
    selectConversation = async function (conversationId, tabElement) {
        await originalSelectConversation(conversationId, tabElement);
        startConversationPolling();
    };

    // Override selectContainer to stop polling when switching containers
    const originalSelectContainer = selectContainer;
    selectContainer = function (element) {
        stopConversationPolling();
        originalSelectContainer(element);
    };

    // Track completed containers
    let completedContainers = new Set();

    async function checkContainerStatus() {
        try {
            const response = await fetch('/api/containers/status');
            const statusData = await response.json();

            for (const container of statusData) {
                const containerEl = document.querySelector(`.container-item[data-name="${container.name}"]`);
                if (!containerEl) continue;

                // Check if any conversation in this container is completed
                const hasCompleted = container.conversations.some(conv => conv.completed);
                const allCompleted = container.conversations.length > 0 &&
                    container.conversations.every(conv => conv.completed);

                if (allCompleted && !completedContainers.has(container.name)) {
                    completedContainers.add(container.name);

                    // Trigger flag detection when container completes
                    triggerFlagDetection(container.name);
                } else if (!allCompleted && completedContainers.has(container.name)) {
                    completedContainers.delete(container.name);
                }
            }
        } catch (error) {
            console.error('Failed to check container status:', error);
        }
    }

    // Track containers that have been checked for flags
    let flagCheckedContainers = new Set();

    async function triggerFlagDetection(containerName) {
        if (flagCheckedContainers.has(containerName)) return;
        flagCheckedContainers.add(containerName);

        try {
            const response = await fetch(`/api/container/${containerName}/check_flag`, {
                method: 'POST'
            });
            const result = await response.json();

            if (result.flag_found && result.flag) {
                // Log that flag was found (no UI notification)
                console.log(`Flag found for ${containerName}: ${result.flag}`);
            }
        } catch (error) {
            console.error('Failed to check for flag:', error);
        }
    }

    // Poll container status every 5 seconds
    setInterval(checkContainerStatus, 5000);
    // Check immediately on page load
    checkContainerStatus();

    // Support deep linking from flags page via ?container= parameter
    const urlParams = new URLSearchParams(window.location.search);
    const targetContainer = urlParams.get('container');
    if (targetContainer) {
        // Wait for containers to load, then select the target
        setTimeout(() => {
            const containerEl = document.querySelector(`.container-item[data-name="${targetContainer}"]`);
            if (containerEl) {
                selectContainer(containerEl);
            }
        }, 500);
    }
</script>
{% endblock %}